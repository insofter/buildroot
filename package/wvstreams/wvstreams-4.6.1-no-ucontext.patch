--- wvstreams-4.6.1/include/wvtask.h	2008-07-14 21:11:35.000000000 +0200
+++ buildroot/_BUILD/build/wvstreams-4.6.1/include/wvtask.h	2013-03-17 17:25:15.307883093 +0100
@@ -24,7 +24,6 @@
 #include "wvstreamsdebugger.h"
 #include "wvstringlist.h"
 #include "setjmp.h"
-#include <ucontext.h>
 
 #define WVTASK_MAGIC 0x123678
 
@@ -50,12 +49,10 @@
     int tid;
     
     size_t stacksize;
-    void *stack;
     bool running, recycled;
     
     WvTaskMan &man;
-    ucontext_t mystate;	// used for resuming the task
-    ucontext_t func_call, func_return;
+    jmp_buf mystate;	// used for resuming the task
     
     TaskFunc *func;
     void *userdata;
@@ -94,13 +91,13 @@
     static void call_func(WvTask *task);
 
     static char *stacktop;
-    static ucontext_t stackmaster_task;
+    static jmp_buf stackmaster_task;
     
     static WvTask *stack_target;
-    static ucontext_t get_stack_return;
+    static jmp_buf get_stack_return;
     
     static WvTask *current_task;
-    static ucontext_t toplevel;
+    static jmp_buf toplevel;
     
     WvTaskMan();
     virtual ~WvTaskMan();
--- wvstreams-4.6.1/utils/wvtask.cc	2009-05-13 23:42:52.000000000 +0200
+++ wvstreams-4.6.1/utils/wvtask.cc	2013-03-17 16:53:50.651834837 +0100
@@ -32,10 +32,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <assert.h>
-#include <sys/mman.h>
-#include <signal.h>
-#include <unistd.h>
-#include <sys/resource.h>
 
 #ifdef HAVE_VALGRIND_MEMCHECK_H
 #include <valgrind/memcheck.h>
@@ -60,7 +56,7 @@
 WvTaskMan *WvTaskMan::singleton;
 int WvTaskMan::links, WvTaskMan::magic_number;
 WvTaskList WvTaskMan::all_tasks, WvTaskMan::free_tasks;
-ucontext_t WvTaskMan::stackmaster_task, WvTaskMan::get_stack_return,
+jmp_buf WvTaskMan::stackmaster_task, WvTaskMan::get_stack_return,
     WvTaskMan::toplevel;
 WvTask *WvTaskMan::current_task, *WvTaskMan::stack_target;
 char *WvTaskMan::stacktop;
@@ -198,9 +194,7 @@
     
     stacktop = (char *)alloca(0);
     
-    context_return = 0;
-    assert(getcontext(&get_stack_return) == 0);
-    if (context_return == 0)
+    if (setjmp(get_stack_return) == 0)
     {
 	// initial setup - start the stackmaster() task (never returns!)
 	stackmaster();
@@ -257,22 +251,18 @@
         
     WvTask *old_task = current_task;
     current_task = &task;
-    ucontext_t *state;
+    jmp_buf *state;
     
     if (!old_task)
 	state = &toplevel; // top-level call (not in an actual task yet)
     else
 	state = &old_task->mystate;
     
-    context_return = 0;
-    assert(getcontext(state) == 0);
-    int newval = context_return;
+    int newval = setjmp(*state);
     if (newval == 0)
     {
 	// saved the state, now run the task.
-        context_return = val;
-        setcontext(&task.mystate);
-        return -1;
+	longjmp(task.mystate, val);
     }
     else
     {
@@ -318,15 +308,11 @@
     }
 #endif
 		
-    context_return = 0;
-    assert(getcontext(&current_task->mystate) == 0);
-    int newval = context_return;
+    int newval = setjmp(current_task->mystate);
     if (newval == 0)
     {
 	// saved the task state; now yield to the toplevel.
-        context_return = val;
-        setcontext(&toplevel);
-        return -1;
+	longjmp(toplevel, val);
     }
     else
     {
@@ -340,38 +326,14 @@
 
 void WvTaskMan::get_stack(WvTask &task, size_t size)
 {
-    context_return = 0;
-    assert(getcontext(&get_stack_return) == 0);
-    if (context_return == 0)
+    if (setjmp(get_stack_return) == 0)
     {
 	assert(magic_number == -WVTASK_MAGIC);
 	assert(task.magic_number == WVTASK_MAGIC);
-
-        if (!use_shared_stack())
-        {
-#if defined(__linux__) && (defined(__386__) || defined(__i386) || defined(__i386__))
-            static char *next_stack_addr = (char *)0xB0000000;
-            static const size_t stack_shift = 0x00100000;
-
-            next_stack_addr -= stack_shift;
-#else
-            static char *next_stack_addr = NULL;
-#endif
-        
-            task.stack = mmap(next_stack_addr, task.stacksize,
-                PROT_READ | PROT_WRITE,
-#ifndef MACOS 
-                MAP_PRIVATE | MAP_ANONYMOUS,
-#else
-                MAP_PRIVATE,
-#endif
-                -1, 0);
-        }
 	
 	// initial setup
 	stack_target = &task;
-	context_return = size/1024 + (size%1024 > 0);
-	setcontext(&stackmaster_task);
+	longjmp(stackmaster_task, size/1024 + (size%1024 > 0));
     }
     else
     {
@@ -408,9 +370,7 @@
     {
 	assert(magic_number == -WVTASK_MAGIC);
 	
-        context_return = 0;
-        assert(getcontext(&stackmaster_task) == 0);
-        val = context_return;
+	val = setjmp(stackmaster_task);
 	if (val == 0)
 	{
 	    assert(magic_number == -WVTASK_MAGIC);
@@ -418,37 +378,31 @@
 	    // just did setjmp; save stackmaster's current state (with
 	    // all current stack allocations) and go back to get_stack
 	    // (or the constructor, if that's what called us)
-            context_return = 1;
-            setcontext(&get_stack_return);
+	    longjmp(get_stack_return, 1);
 	}
 	else
 	{
 	    valgrind_fix(stacktop);
 	    assert(magic_number == -WVTASK_MAGIC);
 	    
-	    total = (val+1) * (size_t)1024;
-	    
-            if (!use_shared_stack())
-                total = 1024; // enough to save the do_task stack frame
-
 	    // set up a stack frame for the new task.  This runs once
 	    // per get_stack.
-            //alloc_stack_and_switch(total);
 	    do_task();
 	    
 	    assert(magic_number == -WVTASK_MAGIC);
+	    
+	    // allocate the stack area so we never use it again
+	    total = (val+1) * (size_t)1024;
+	    alloca(total);
 
-            // allocate the stack area so we never use it again
-            alloca(total);
-
-            // a little sentinel so we can detect stack overflows
-            stack_target->stack_magic = (int *)alloca(sizeof(int));
-            *stack_target->stack_magic = WVTASK_MAGIC;
-            
-            // clear the stack to 0x42 so we can count unused stack
-            // space later.
+	    // a little sentinel so we can detect stack overflows
+	    stack_target->stack_magic = (int *)alloca(sizeof(int));
+	    *stack_target->stack_magic = WVTASK_MAGIC;
+	    
+	    // clear the stack to 0x42 so we can count unused stack
+	    // space later.
 #if TASK_DEBUG
-            memset(stack_target->stack_magic + 1, 0x42, total - 1024);
+	    memset(stack_target->stack_magic + 1, 0x42, total - 1024);
 #endif
 	}
     }
@@ -473,9 +427,7 @@
     assert(task->magic_number == WVTASK_MAGIC);
 	
     // back here from longjmp; someone wants stack space.    
-    context_return = 0;
-    assert(getcontext(&task->mystate) == 0);
-    if (context_return == 0)
+    if (setjmp(task->mystate) == 0)
     {
 	// done the setjmp; that means the target task now has
 	// a working jmp_buf all set up.  Leave space on the stack
@@ -501,30 +453,10 @@
 	    
 	    if (task->func && task->running)
 	    {
-                if (use_shared_stack())
-                {
-                    // this is the task's main function.  It can call yield()
-                    // to give up its timeslice if it wants.  Either way, it
-                    // only returns to *us* if the function actually finishes.
-                    task->func(task->userdata);
-                }
-                else
-                {
-                    assert(getcontext(&task->func_call) == 0);
-                    task->func_call.uc_stack.ss_size = task->stacksize;
-                    task->func_call.uc_stack.ss_sp = task->stack;
-                    task->func_call.uc_stack.ss_flags = 0;
-                    task->func_call.uc_link = &task->func_return;
-                    Dprintf("WvTaskMan: makecontext #%d (%s)\n",
-                            task->tid, (const char *)task->name);
-                    makecontext(&task->func_call,
-                            (void (*)(void))call_func, 1, task);
-
-                    context_return = 0;
-                    assert(getcontext(&task->func_return) == 0);
-                    if (context_return == 0)
-                        setcontext(&task->func_call);
-                }
+		// this is the task's main function.  It can call yield()
+		// to give up its timeslice if it wants.  Either way, it
+		// only returns to *us* if the function actually finishes.
+		task->func(task->userdata);
 		
 		// the task's function terminated.
 		task->name = "DEAD";
@@ -539,30 +471,13 @@
 
 const void *WvTaskMan::current_top_of_stack()
 {
-#ifdef HAVE_LIBC_STACK_END
-    extern const void *__libc_stack_end;
-    if (use_shared_stack() || current_task == NULL)
-        return __libc_stack_end;
-    else
-        return (const char *)current_task->stack + current_task->stacksize;
-#else
     return 0;
-#endif
 }
 
 
 size_t WvTaskMan::current_stacksize_limit()
 {
-    if (use_shared_stack() || current_task == NULL)
-    {
-        struct rlimit rl;
-        if (getrlimit(RLIMIT_STACK, &rl) == 0)
-            return size_t(rl.rlim_cur);
-        else
-            return 0;
-    }
-    else
-        return size_t(current_task->stacksize);
+    return size_t(current_task->stacksize);
 }
 
     
